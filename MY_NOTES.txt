Was it already done??
https://sourceforge.net/projects/winntposix/files/winntposix/1.1.X/psx-src-1.1.4.zip/download

# Prefix for krnl calls and user calls
## Win32 prefix:
- Zw means NT syscalls that are called from kernelland (ntoskrnl)
- Nt means NT syscalls that are called from userland (ntdll)
## MiniROS prefix:
- Zw -> sys_ (eg: ZwOpen -> sys_open)
- Nt -> null (eg: NtOpen -> open)

# FileSystem
- \\?? -> ROOT DEVICE
-  \SystemRoot\

# smss
initialization:
- mk \SmApiPort
- Load win32k. Kmode
- Csrss subsystem
- Winlogon

# psxss 
Was csrss ment to have a posix dll server? __REACTOS__ diffs suggests me so

1. Create PSX object directory (\POSIX\)
1. Connect to smss.exe (SmConnectToSm)





# CreateProcess (w2k)
NOTE: This is from CreateProcess win32 api?
- Ldr EXE
- Create EPROCESS
- Create ETHREAD
- Notify csrss.exe
- Start initial thread by csrss.exe
- Return to caller

> In short, you can't directly create a process that is not a Win32 process
This explains why it doesn't have EPROCESS->PsxContext

# Original psxss idea
/bin/simple.exe, subsystem type = POSIX application
Pass on smss
smss pass on psxss
psxss calls SmpLoadDeferredSystem with "posix.exe /I /bin/simple.exe" (or whatever the cmd was)
Application starts
so POSIX.EXE is a Win32 app

# lxcore.sys (pico kernel nt10)
- Ldr EXE
- Create EPROCESS
- Create ETHREAD
- Notify picoprovider lxcore.sys
- Setup thread
- Start minimal thread
- Return to caller

"Do we need csrss.exe? NO"
"Do we need our own psxss.exe? YES"

## How to write a ss for nt?
1. Create open port to SmPortApi
 * The CsrSbApiRequestThread routine handles incoming messages or connection
 * requests on the SM API LPC Port.
Dispatches:
PSB_API_ROUTINE CsrServerSbApiDispatch[SbpMaxApiNumber - SbpCreateSession] =
{
    CsrSbCreateSession,
    CsrSbTerminateSession,
    CsrSbForeignSessionComplete,
    CsrSbCreateProcess
};
1. Allocate a new process
2. Destroy a new process
3. Not used
4. Not used

# lnx32k.sys (internal name for the subsystem handling of the kernel driver of lxss.sys)
- win32k callouts are not called unless Win32Context != NULL && Process == GUI_PROCESS
This is an issue when we want a subsystem for linux because we don't have any Win32Context to hook.
I falled back to making lxss.sys a win32k.sys wannabe

## How to create new service for syscall handling of any subsystem:

Refeer to https://stackoverflow.com/questions/61724100/reactos-where-are-the-ntdll-dll-stubs
 for making stubs (sdk/include/asm/syscalls.inc & ntoskrnl/sysfuncs.h)

https://codemachine.com/articles/system_call_instructions.html 
This explains why the macro is like this. 

# Questions
Should we force map something like 0x7FFE0300 for our subsystem?
Should we simply use "syscall" or "int 0x2e"?
Should we not use sysenter? I think linux does not use it
Is "SyscallId" mapped to syscall + serivce id?

This context switch has to be done on psxsc.dll (POSIX ntdll.dll)

We register syscalls on lxcore.sys with this: (KeAddSystemServiceTable)
https://community.osr.com/discussion/271137/is-it-still-possible-to-add-a-3-or-4-sdt-entry-in-windows-7
refeer to win32k.sys for information on how it register stuff.

We register the same syscalls for the pico process dispatcher and syscall dispatcher for posix.
Also refeer to this https://stackoverflow.com/questions/4380159/writing-a-windows-nt-subsystem
https://news.ycombinator.com/item?id=20856780


# The real scope of ntdll.dll
1. Nt kernel defines two entrypoint for a function:
- User-land entrypoint where the previous called KeGetPreviousMode == UserLand, this starts with Nt#function
Nt functions performs buffer and parameter validation from Userland
- Kernel-land entrypoint that are called from kernel drivers and so on, this does not have validations and are
specific in style of kernel api

Both this two functions are exported to ntoskrnl.exe, the main kernel.
How do we access this functions? Introduce NTDLL. The syscall converter and disaptcher.
- NTDLL exports various stubs that will be called by the user application which will return to the usual
syscall interrupt (int 0x2e)

x86 dilemma: sysenter/sysexit or int?
Windows may enter a syscall as a fast syscall (using sysenter) or with an interrupt (int syscall)
NTDLL exports both this two functions (sysenter/sysexit and int) as three functions. This are references 
in kernel PspLookupKernelUserEntryPoints, this is saved in SharedUserData->SystemCall.
This should be 

# How syscall stubs are generated in ntdll.dll
Two main files are used for this purpose: 

- include/asm/syscalls.inc which defines the stub functions
- syscalls.h which defines the syscalls functions and arg count (arg count is required for stack save)
- This two files are included in the linked ntdll.S (ntdllsys_asm from ntoskrnl)

## syscalls.inc (x86/x64/mips/ppc)
- STUB_U (Userland):
    1. Create a fake label for Zw (Zw#Name) [ASM: MAKE_LABEL]
    2. Make the label a jump to the userland Nt proc (Nt#Name) [ASM: START_PROC]
    3. Create the userland Nt proc
    proc for userland: (x86) [ASM: STUBCODE_U]
     0. save frame/stack for argument count
     1. mov eax, syscall
     2. mov edx, ntdll shared syscall dispatcher
     3. call edx
     4. ret esp
- STUB_K (Kernelland)
    1. Create proc for Zw (Zw#Name) [ASM: START_PROC]
    2. Create the kernelland Zw proc [ASM: STUBCODE_K]
    proc for kernelland: (x86)
     0. save frame/stack for argument count
     1. mov eax, syscall
     2. mov edx, pointer to arguments
     3. call KiSystemService
     4. ret esp

## syscalls.inc (arm/arm64)
- STUB_K (Kernelland)
    1. Create a label for the function start and function end (presumably this are pointers)
    2. Export the function name (ZwFuncName which is "Zw$Name")
    3. Define the proc
    proc for kernelland:
     1. mov r12, syscall
     2. call supervisor (svc)
     3. ret lr
    proc for kernelland end name:
     0. null
- STUB_U (Userland)
    This is the same as the kernel land stub with the only difference that it also exports an NtFuncName

## syscalls.inc (common)
- Create and call STUB_U which increment syscall number by 1
- Create and call STUB_K which increment syscall number by 1

# Mysteries:
- Kernel spawns process, win32k.sys is called where? csrss.exe is called where? smss is called where?
- Does this mean that I can just use syscalls.inc with 0x2000-0x2FFF ? And rely the work on psxsc.dll to simple stubs that calls KiEnterSysCall from ntdll.dll?
Yes, as we interrupt to KiSystemService it will redirect it to the proper service dispatcher

- psxsc.dll is meant to be loaded only by POSIX NT apps, no need to think about this with pico processes

# Analysis on Pico Process

PicoProcess is a MicroProcess with a Pico driver provider (lxss.sys) associated
MicroProcess is a Windows process without PEB/TEB/NTDLL.dll and so on

EPROCESS (PicoContext): https://www.vergiliusproject.com/kernels/x64/Windows%2010%20|%202016/2009%2020H2%20(October%202020%20Update)/_EPROCESS
ETHREAD (PicoContext): https://www.vergiliusproject.com/kernels/x64/Windows%2010%20|%202016/2009%2020H2%20(October%202020%20Update)/_ETHREAD
This explains some core concept and the VFS implementation: https://www.usenix.org/system/files/conference/atc13/atc13-howell.pdf

https://www.slideshare.net/zeroSteiner/is-that-a-penguin-in-my-windows
- What lxss and lxcore (lxss signed stub)
- \Driver\lxss
- Syscalls are LxpSyscall_*
- Dispatcher is __cdecl linux syscall dispatcher for 64-bit (int or syscall)
This documents only 64-bit dispatching but 32-bit would be the same as System V

https://raw.githubusercontent.com/ionescu007/lxss/6a3040fadff5ce43d7bfd638a4e5d7dfe8780143/WSL-BlueHat-Final.pdf
- More depth about process architecture
- Expalins ioctl to \Device\lxss and what they do
- Explains what lxssmanager is
- API Names:
-- PsRegisterPicoProvider
-- PspPicoRegistrationDisabled
-- PipInitializeCoreDriversByGroup (reactos has this?)
-- PspPicoProviderRoutines (what is this?)
-- LxpSysDispatch (implemented)
-- LxpTraceSyscall (not implemented)
-- LxpTraceLastSyscall (not implemented)
-- LxpPrintSysLevel (not implemented)
VFS -> //? OB

https://fourcore.io/blogs/how-a-windows-process-is-created-part-1
More in depth on how pico processes are created

https://github.com/ionescu007/lxss/tree/6a3040fadff5ce43d7bfd638a4e5d7dfe8780143
Contains material of the slideshow, this includes information and export calls from lxcore such as for vfs and so on

https://www.cctry.com/thread-301774-1-1.html
List  of all ntoskrnl exported functions, this is where PsPicoContext bla bla is
- Where is the set of the PicoContext from the kernel? Is it private?

https://github.com/kpocza/LoWe/blob/master/docs/howitworks.md
lxcore extendor, this contains the documentation of LxInitialize api and other info on how the VFS works

https://elixir.bootlin.com/linux/latest/source/include/linux/syscalls.h#L502
List of linux syscalls

https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html
Linux loader explanation

https://github.com/thinkcz/pico-toolbox/blob/master/ToolBoxDriver/picostruct.h
Pico process structure documentations

https://pastebin.com/C1NLn3Jn
Exported symbols of lxcore
